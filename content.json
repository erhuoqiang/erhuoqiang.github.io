[{"title":"LRU 缓存算法-C语言","date":"2018-05-08T08:51:50.000Z","path":"2018/05/08/LRU-缓存算法-C语言/","text":"项目背景:去年底项目需求对数据进行缓存并频繁的获取,所以选用LRU对其进行管理以下代码在vs2017下测试通过，无内存泄漏，功能正常LRU介绍 LRUCacheImp.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314#include &quot;LRUCacheImp.h&quot;#define TRY_AGAIN_TIME 10//限定容量200#define MAX_CAPACITY_NUM 200//hashkey最大序号数 0~(MAX_HASH_KEY_NUM-1)#define MAX_HASH_KEY_NUM 65535//#define USE_FreeRTOS_MEM_MANAGE#ifdef USE_FreeRTOS_MEM_MANAGE#define MALLOC(SIZE) pvPortMalloc(SIZE)#define FREE(POINT) vPortFree(POINT)#else #define MALLOC(SIZE) malloc(SIZE)#define FREE(POINT) free(POINT)#endif LRUCache *lrucache = NULL;static void FreeCacheEntry(CacheEntry *entry) &#123; info_printf(&quot;\\n&quot;); if(entry == NULL) &#123; return; &#125; lrucache-&gt;lru_hash_map[entry-&gt;hash_key] = NULL; FREE(entry-&gt;data); FREE(entry);&#125;static void FreeLruList(LRUCache *lrucache) &#123; info_printf(&quot;\\n&quot;); if(lrucache == NULL) &#123; return; &#125; CacheEntry *head_entry = lrucache-&gt;lru_list_head; while(head_entry) &#123; CacheEntry *temp_entry = head_entry-&gt;lru_list_next; FreeCacheEntry(head_entry); head_entry = temp_entry; --lrucache-&gt;lru_list_num; &#125; lrucache-&gt;lru_list_head = NULL; lrucache-&gt;lru_list_tail = NULL; if(lrucache-&gt;lru_list_num != 0) &#123; err_printf(&quot;entry not clear up\\n&quot;); &#125;&#125;static inline unsigned short int HashKey(LRUCache *lrucache, unsigned short int key) &#123; return key%lrucache-&gt;hash_key_max;&#125;static CacheEntry *GetCacheEntryFromHashMap(LRUCache *lrucache, unsigned short int key) &#123; info_printf(&quot;\\n&quot;); if(lrucache == NULL || lrucache-&gt;lru_hash_map == NULL) &#123; return NULL; &#125; unsigned short int hash_key = HashKey(lrucache,key); CacheEntry *entry = lrucache-&gt;lru_hash_map[hash_key]; if(entry) &#123; if(entry-&gt;hash_key == hash_key)&#123; return entry; &#125; else &#123; err_printf(&quot;cache entry hashkey != key\\n&quot;); &#125; &#125; return NULL;&#125;static void RemoveEntryFromList(LRUCache *lrucache, CacheEntry *entry) &#123; info_printf(&quot;\\n&quot;); if(entry == NULL || lrucache-&gt;lru_list_head == NULL)&#123; return; &#125; if(lrucache-&gt;lru_list_head == lrucache-&gt;lru_list_tail) &#123; //only one entry lrucache-&gt;lru_list_head = lrucache-&gt;lru_list_tail = NULL; &#125; else if(lrucache-&gt;lru_list_head == entry) &#123; lrucache-&gt;lru_list_head = entry-&gt;lru_list_next; lrucache-&gt;lru_list_head-&gt;lru_list_pre = NULL; &#125; else if(lrucache-&gt;lru_list_tail == entry) &#123; lrucache-&gt;lru_list_tail = entry-&gt;lru_list_pre; entry-&gt;lru_list_pre-&gt;lru_list_next = NULL; &#125; else &#123; entry-&gt;lru_list_pre-&gt;lru_list_next = entry-&gt;lru_list_next; entry-&gt;lru_list_next-&gt;lru_list_pre = entry-&gt;lru_list_pre; &#125; lrucache-&gt;lru_hash_map[HashKey(lrucache, entry-&gt;hash_key)] = NULL; --lrucache-&gt;lru_list_num;&#125;static void RemoveAndFreeListTailEntry(LRUCache *lrucache) &#123; info_printf(&quot;\\n&quot;); CacheEntry *tail_entry = lrucache-&gt;lru_list_tail; RemoveEntryFromList(lrucache, tail_entry); FreeCacheEntry(tail_entry);&#125;static void InsertEntryToListHead(LRUCache *lrucache, CacheEntry *entry) &#123; info_printf(&quot;\\n&quot;); ++lrucache-&gt;lru_list_num; if (lrucache-&gt;lru_list_num &gt; lrucache-&gt;cache_capacity) &#123; RemoveAndFreeListTailEntry(lrucache); &#125; if(lrucache-&gt;lru_list_head == NULL &amp;&amp; lrucache-&gt;lru_list_tail == NULL) &#123; entry-&gt;lru_list_next = NULL; entry-&gt;lru_list_pre = NULL; lrucache-&gt;lru_list_head = lrucache-&gt;lru_list_tail = entry; &#125; else &#123; entry-&gt;lru_list_next = lrucache-&gt;lru_list_head; entry-&gt;lru_list_pre = NULL; lrucache-&gt;lru_list_head-&gt;lru_list_pre = entry; lrucache-&gt;lru_list_head = entry; &#125; lrucache-&gt;lru_hash_map[HashKey(lrucache, entry-&gt;hash_key)] = entry;&#125;static void UpdateLruListEntryPosition(LRUCache *lrucache, CacheEntry *entry) &#123; info_printf(&quot;\\n&quot;); RemoveEntryFromList(lrucache, entry); InsertEntryToListHead(lrucache, entry);&#125;DATA_TYPE *NewDataType(LRUCache *lrucache, unsigned int byte) &#123; info_printf(&quot;\\n&quot;); if(lrucache == NULL) &#123; return NULL; &#125; DATA_TYPE *data = (DATA_TYPE *)MALLOC(byte); int try_again_time = TRY_AGAIN_TIME; while(data == NULL) &#123; RemoveAndFreeListTailEntry(lrucache); data = (DATA_TYPE *)MALLOC(byte); --try_again_time; if(try_again_time &lt;= 0) &#123; err_printf(&quot;malloc return NULL,already try call again %d time\\n&quot;,TRY_AGAIN_TIME); return NULL; &#125; &#125;; return data;&#125;int LruCacheCreate(unsigned short int capacity, unsigned short int hashkeymax, LRUCache **lrucache) &#123; info_printf(&quot;\\n&quot;); if(lrucache == NULL) &#123; return -2; &#125; if(capacity &gt; hashkeymax) &#123; capacity = hashkeymax; warn_printf(&quot;LRUCache capacity &gt; hashkeymax,then capacity set to %d\\n&quot;,hashkeymax); &#125; *lrucache = (LRUCache *)MALLOC(sizeof(LRUCache)); if(*lrucache == NULL) &#123; err_printf(&quot;malloc return null\\n&quot;); return -1; &#125; LRUCache *cache = *lrucache; cache-&gt;cache_capacity = capacity; cache-&gt;hash_key_max = hashkeymax; cache-&gt;lru_list_num = 0; cache-&gt;lru_hash_map = (CacheEntry **)MALLOC(sizeof(CacheEntry *) * hashkeymax); if(cache-&gt;lru_hash_map == NULL) &#123; err_printf(&quot;malloc return null\\n&quot;); return -1; &#125; memset((void *)cache-&gt;lru_hash_map, 0, sizeof(CacheEntry *) * hashkeymax); cache-&gt;lru_list_head = NULL; cache-&gt;lru_list_tail = NULL; err_printf(&quot;lru cache init success\\n&quot;); return 0;&#125;int LRUCacheDestory(LRUCache *lrucache) &#123; info_printf(&quot;\\n&quot;); if(lrucache == NULL) &#123; return -1; &#125; FreeLruList(lrucache); FREE(lrucache-&gt;lru_hash_map); FREE(lrucache); return 0;&#125; int LRUCacheSet(LRUCache *lrucache, unsigned short int key, DATA_TYPE *data) &#123; info_printf(&quot;\\n&quot;); if(data == NULL || lrucache == NULL) &#123; return -1; &#125; CacheEntry *entry = GetCacheEntryFromHashMap(lrucache, key); if(entry == NULL) &#123; entry = (CacheEntry *)MALLOC(sizeof(CacheEntry)); int try_again_time = TRY_AGAIN_TIME; while(entry == NULL) &#123; RemoveAndFreeListTailEntry(lrucache); entry = (CacheEntry *)MALLOC(sizeof(CacheEntry)); --try_again_time; if(try_again_time &lt;= 0) &#123; err_printf(&quot;malloc return NULL,already try call again %d time\\n&quot;,TRY_AGAIN_TIME); return -1; &#125; &#125; entry-&gt;data = data; entry-&gt;hash_key = HashKey(lrucache,key); InsertEntryToListHead(lrucache, entry); &#125; else &#123; if(entry-&gt;data != data) &#123; FREE(entry-&gt;data); entry-&gt;data = data; &#125; UpdateLruListEntryPosition(lrucache, entry); &#125; return 0;&#125;DATA_TYPE *LRUCacheGet(LRUCache *lruCache, unsigned short int key) &#123; info_printf(&quot;\\n&quot;); if(lruCache == NULL) &#123; return NULL; &#125; CacheEntry *entry = GetCacheEntryFromHashMap(lruCache, key); if (entry != NULL) &#123; UpdateLruListEntryPosition(lruCache, entry); return entry-&gt;data; &#125; else &#123; return NULL; &#125;&#125;unsigned char QueryHashKeyMapHasData(LRUCache *lruCache, unsigned short int key) &#123; info_printf(&quot;\\n&quot;); if(lruCache == NULL) &#123; return NULL; &#125; CacheEntry *entry = GetCacheEntryFromHashMap(lruCache, key); if (entry != NULL) &#123; return 1; &#125; return 0;&#125;void LruCacheInit(void) &#123; if(lrucache == NULL) &#123; LruCacheCreate(MAX_CAPACITY_NUM, MAX_HASH_KEY_NUM, &amp;lrucache); &#125;&#125;void ClearLruListCache(void) &#123; FreeLruList(lrucache);&#125;//void LRUCachePrint(LRUCache *lrucache) &#123;// info_printf(&quot;\\n&quot;);// info_printf(&quot;\\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);// info_printf(&quot;cache (key data):\\n&quot;);// CacheEntry *entry = lrucache-&gt;lru_list_head;// while (entry) &#123;// printf(&quot;(%d, %d)\\n&quot;, entry-&gt;hash_key, *entry-&gt;data);// entry = entry-&gt;lru_list_next;// &#125;// for (int i = 0; i &lt; lrucache-&gt;hash_key_max; i++) &#123;// if(i % 10 == 0) &#123;// printf(&quot;\\n&quot;);// &#125;// printf(&quot;%x &quot;, (int)lrucache-&gt;lru_hash_map[i]);// &#125;// info_printf(&quot;\\n&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\\n&quot;);//&#125;//#include &lt;crtdbg.h&gt;//#ifdef _DEBUG //#define new new(_NORMAL_BLOCK, __FILE__, __LINE__) //#endif //void EnableMemLeakCheck()//&#123;// int tmpFlag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);// tmpFlag |= _CRTDBG_LEAK_CHECK_DF;// _CrtSetDbgFlag(tmpFlag);//&#125;//int main() &#123;// EnableMemLeakCheck();// LRUCache *lrucache = NULL;// LruCacheCreate(10, 10, &amp;lrucache);// int *temp = NewDataType(lrucache, 0x10000000);// *temp = 108;// LRUCacheSet(lrucache, 20 + *temp, temp);// //temp = NewDataType(lrucache, sizeof(int));// *temp = 108;// LRUCacheSet(lrucache, 20 + *temp, temp);// for (int i = 0; i &lt; 80; i++) &#123;// temp = NewDataType(lrucache, sizeof(int));// *temp = i%8;// LRUCacheSet(lrucache, *temp, temp);// &#125;// printf(&quot;%d\\n&quot;,*LRUCacheGet(lrucache,1));// LRUCachePrint(lrucache);// temp = NewDataType(lrucache, 0xffffffff);// printf(&quot;%d\\n&quot;, *LRUCacheGet(lrucache, 5));// LRUCachePrint(lrucache);// temp = NewDataType(lrucache, 0xffffffff);// LRUCachePrint(lrucache);// LRUCacheDestory(lrucache);// while(1);//&#125; LRUCacheImp.h12345678910111213141516171819202122232425262728#ifndef _LRU_CACHE_IMP_H_#define _LRU_CACHE_IMP_H_#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &quot;Debug.h&quot;typedef int DATA_TYPE;typedef struct CacheEntry &#123; unsigned short int hash_key; DATA_TYPE *data; struct CacheEntry *lru_list_pre; struct CacheEntry *lru_list_next;&#125; CacheEntry;typedef struct LRUCache &#123; struct CacheEntry **lru_hash_map; //hashmap struct CacheEntry *lru_list_head; //point to lru list head entry struct CacheEntry *lru_list_tail; //point to lru list tail entry unsigned short int lru_list_num; //current lru list entry num unsigned short int cache_capacity; //max entry num unsigned short int hash_key_max; //key range is 0~hash_key_max&#125; LRUCache;#endif //_LRU_CACHE_IMP_H_ LRUCache.h123456789101112131415161718192021#ifndef _LRU_CACHE_H_#define _LRU_CACHE_H_// Created by xiaozhiqiangtypedef struct LRUCache LRUCache;typedef struct CacheEntry CacheEntry;typedef int DATA_TYPE;extern LRUCache *lrucache;void LruCacheInit(void);int LruCacheCreate(unsigned short int capacity, unsigned short int hashkeymax, LRUCache **lrucache);int LRUCacheDestory(LRUCache *lrucache);DATA_TYPE *LRUCacheGet(LRUCache *lrucache, unsigned short int key);int LRUCacheSet(LRUCache *lrucache, unsigned short int key, DATA_TYPE *data);//void LRUCachePrint(void *lruCache);DATA_TYPE *NewDataType(LRUCache *lrucache, unsigned int byte);unsigned char QueryHashKeyMapHasData(LRUCache *lruCache, unsigned short int key);void ClearLruListCache(void);#endif //_LRU_CACHE_H_ Debug.h1234567891011121314151617181920212223242526272829303132#ifndef _DEBUG_H_#define _DEBUG_H_#include &lt;stdio.h&gt;#undef SHOW_INFO#define SHOW_INFO#ifdef SHOW_INFO#define info_printf(...) printf(&quot;[INFO] %s (%d):&quot;, __func__, __LINE__);printf(__VA_ARGS__)#else#define info_printf(...)#endif#undef WARNING#define WARNING#ifdef WARNING#define warn_printf(...) printf(&quot;[WARNING] %s (%d):&quot;, __func__, __LINE__);printf(__VA_ARGS__)#else#define warn_printf(...)#endif#undef ERROR#define ERROR#ifdef ERROR#define err_printf(...) printf(&quot;[ERROR] %s (%d):&quot;, __func__, __LINE__);printf(__VA_ARGS__)#else#define err_printf(...)#endif#endif //_DEBUG_H_ 补充前几天在同事的影响下,决定开始写自己的技术博客,并参考了同事关于搭建Hexo博客的文章还有网上一篇关于Hexo的文章. 同事-博客手把手教你使用Hexo搭建博客","tags":[]},{"title":"520 why","date":"2018-05-06T13:54:05.000Z","path":"2018/05/06/520-why/","text":"I love you wanghanyingwrite by erhuoqiang2018.5.6","tags":[]}]