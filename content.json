[{"title":"vimtutor总结汇总.md","date":"2018-05-10T11:25:03.000Z","path":"2018/05/10/vimtutor总结汇总-md/","text":"将vimtutor里面的总结汇总在一起便于复习 第一章 1234567891011121314151617 1. 光标在屏幕文本中的移动既可以用箭头键，也可以使用 hjkl 字母键。 h (左移) j (下行) k (上行) l (右移) 2. 欲进入 Vim 编辑器(从命令行提示符)，请输入：vim 文件名 &lt;回车&gt; 3. 欲退出 Vim 编辑器，请输入 &lt;ESC&gt; :q! &lt;回车&gt; 放弃所有改动。 或者输入 &lt;ESC&gt; :wq &lt;回车&gt; 保存改动。 4. 在正常模式下删除光标所在位置的字符，请按： x 5. 欲插入或添加文本，请输入： i 输入欲插入文本 &lt;ESC&gt; 在光标前插入文本 A 输入欲添加文本 &lt;ESC&gt; 在一行后添加文本特别提示：按下 &lt;ESC&gt; 键会带您回到正常模式或者撤消一个不想输入或部分完整的命令。 第二章 1234567891011121314151617181. 欲从当前光标删除至下一个单词，请输入：dw2. 欲从当前光标删除至当前行末尾，请输入：d$3. 欲删除整行，请输入：dd4. 欲重复一个动作，请在它前面加上一个数字：2w5. 在正常模式下修改命令的格式是： operator [number] motion 其中： operator - 操作符，代表要做的事情，比如 d 代表删除 [number] - 可以附加的数字，代表动作重复的次数 motion - 动作，代表在所操作的文本上的移动，例如 w 代表单词(word)， $ 代表行末等等。6. 欲移动光标到行首，请按数字0键：07. 欲撤消以前的操作，请输入：u (小写的u) 欲撤消在一行中所做的改动，请输入：U (大写的U) 欲撤消以前的撤消命令，恢复以前的操作结果，请输入：CTRL-R 第三章 12345678910111213141. 要重新置入已经删除的文本内容，请按小写字母 p 键。该操作可以将已删除 的文本内容置于光标之后。如果最后一次删除的是一个整行，那么该行将置 于当前光标所在行的下一行。2. 要替换光标所在位置的字符，请输入小写的 r 和要替换掉原位置字符的新字 符即可。3. 更改类命令允许您改变从当前光标所在位置直到动作指示的位置中间的文本。 比如输入 ce 可以替换当前光标到单词的末尾的内容；输入 c$ 可以替换当 前光标到行末的内容。4. 更改类命令的格式是：c [number] motion 第四章 12345678910111213141516171819201. CTRL-G 用于显示当前光标所在位置和文件状态信息。 G 用于将光标跳转至文件最后一行。 先敲入一个行号然后输入大写 G 则是将光标移动至该行号代表的行。 gg 用于将光标跳转至文件第一行。2. 输入 / 然后紧随一个字符串是在当前所编辑的文档中正向查找该字符串。 输入 ? 然后紧随一个字符串则是在当前所编辑的文档中反向查找该字符串。 完成一次查找之后按 n 键是重复上一次的命令，可在同一方向上查 找下一个匹配字符串所在；或者按大写 N 向相反方向查找下一匹配字符串所在。 CTRL-O 带您跳转回较旧的位置，CTRL-I 则带您到较新的位置。3. 如果光标当前位置是括号(、)、[、]、&#123;、&#125;，按 % 会将光标移动到配对的括号上。4. 在一行内替换头一个字符串 old 为新的字符串 new，请输入 :s/old/new 在一行内替换所有的字符串 old 为新的字符串 new，请输入 :s/old/new/g 在两行内替换所有的字符串 old 为新的字符串 new，请输入 :#,#s/old/new/g 在文件内替换所有的字符串 old 为新的字符串 new，请输入 :%s/old/new/g 进行全文替换时询问用户确认每个替换需添加 c 标志 :%s/old/new/gc 第五章 12345678910111213141516171. :!command 用于执行一个外部命令 command。 请看一些实际例子：(MS-DOS) (Unix) :!dir :!ls - 用于显示当前目录的内容。 :!del FILENAME :!rm FILENAME - 用于删除名为 FILENAME 的文件。2. :w FILENAME 可将当前 VIM 中正在编辑的文件保存到名为 FILENAME 的文 件中。3. v motion :w FILENAME 可将当前编辑文件中可视模式下选中的内容保存到文件 FILENAME 中。4. :r FILENAME 可提取磁盘文件 FILENAME 并将其插入到当前文件的光标位置 后面。5. :r !dir 可以读取 dir 命令的输出并将其放置到当前文件的光标位置后面。 第六章 12345678910111213141516171819 1. 输入小写的 o 可以在光标下方打开新的一行并进入插入模式。 输入大写的 O 可以在光标上方打开新的一行。 2. 输入小写的 a 可以在光标所在位置之后插入文本。 输入大写的 A 可以在光标所在行的行末之后插入文本。 3. e 命令可以使光标移动到单词末尾。 4. 操作符 y 复制文本，p 粘贴先前复制的文本。 5. 输入大写的 R 将进入替换模式，直至按 &lt;ESC&gt; 键回到正常模式。 6. 输入 :set xxx 可以设置 xxx 选项。一些有用的选项如下： &apos;ic&apos; &apos;ignorecase&apos; 查找时忽略字母大小写&apos;is&apos; &apos;incsearch&apos; 查找短语时显示部分匹配&apos;hls&apos; &apos;hlsearch&apos; 高亮显示所有的匹配短语 选项名可以用完整版本，也可以用缩略版本。 7. 在选项前加上 no 可以关闭选项： :set noic 第七章 1234567891011121. 输入 :help 或者按 &lt;F1&gt; 键或 &lt;Help&gt; 键可以打开帮助窗口。2. 输入 :help cmd 可以找到关于 cmd 命令的帮助。3. 输入 CTRL-W CTRL-W 可以使您在窗口之间跳转。4. 输入 :q 以关闭帮助窗口5. 您可以创建一个 vimrc 启动脚本文件用来保存您偏好的设置。6. 当输入 : 命令时，按 CTRL-D 可以查看可能的补全结果。 按 &lt;TAB&gt; 可以使用一个补全。","tags":[]},{"title":"LRU 缓存算法-C语言","date":"2018-05-08T08:51:50.000Z","path":"2018/05/08/LRU-缓存算法-C语言/","text":"项目背景:去年底项目需求对数据进行缓存并频繁的获取,所以选用LRU对其进行管理以下代码在vs2017下测试通过，无内存泄漏，功能正常LRU介绍 LRUCacheImp.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314#include &quot;LRUCacheImp.h&quot;#define TRY_AGAIN_TIME 10//限定容量200#define MAX_CAPACITY_NUM 200//hashkey最大序号数 0~(MAX_HASH_KEY_NUM-1)#define MAX_HASH_KEY_NUM 65535//#define USE_FreeRTOS_MEM_MANAGE#ifdef USE_FreeRTOS_MEM_MANAGE#define MALLOC(SIZE) pvPortMalloc(SIZE)#define FREE(POINT) vPortFree(POINT)#else #define MALLOC(SIZE) malloc(SIZE)#define FREE(POINT) free(POINT)#endif LRUCache *lrucache = NULL;static void FreeCacheEntry(CacheEntry *entry) &#123; info_printf(&quot;\\n&quot;); if(entry == NULL) &#123; return; &#125; lrucache-&gt;lru_hash_map[entry-&gt;hash_key] = NULL; FREE(entry-&gt;data); FREE(entry);&#125;static void FreeLruList(LRUCache *lrucache) &#123; info_printf(&quot;\\n&quot;); if(lrucache == NULL) &#123; return; &#125; CacheEntry *head_entry = lrucache-&gt;lru_list_head; while(head_entry) &#123; CacheEntry *temp_entry = head_entry-&gt;lru_list_next; FreeCacheEntry(head_entry); head_entry = temp_entry; --lrucache-&gt;lru_list_num; &#125; lrucache-&gt;lru_list_head = NULL; lrucache-&gt;lru_list_tail = NULL; if(lrucache-&gt;lru_list_num != 0) &#123; err_printf(&quot;entry not clear up\\n&quot;); &#125;&#125;static inline unsigned short int HashKey(LRUCache *lrucache, unsigned short int key) &#123; return key%lrucache-&gt;hash_key_max;&#125;static CacheEntry *GetCacheEntryFromHashMap(LRUCache *lrucache, unsigned short int key) &#123; info_printf(&quot;\\n&quot;); if(lrucache == NULL || lrucache-&gt;lru_hash_map == NULL) &#123; return NULL; &#125; unsigned short int hash_key = HashKey(lrucache,key); CacheEntry *entry = lrucache-&gt;lru_hash_map[hash_key]; if(entry) &#123; if(entry-&gt;hash_key == hash_key)&#123; return entry; &#125; else &#123; err_printf(&quot;cache entry hashkey != key\\n&quot;); &#125; &#125; return NULL;&#125;static void RemoveEntryFromList(LRUCache *lrucache, CacheEntry *entry) &#123; info_printf(&quot;\\n&quot;); if(entry == NULL || lrucache-&gt;lru_list_head == NULL)&#123; return; &#125; if(lrucache-&gt;lru_list_head == lrucache-&gt;lru_list_tail) &#123; //only one entry lrucache-&gt;lru_list_head = lrucache-&gt;lru_list_tail = NULL; &#125; else if(lrucache-&gt;lru_list_head == entry) &#123; lrucache-&gt;lru_list_head = entry-&gt;lru_list_next; lrucache-&gt;lru_list_head-&gt;lru_list_pre = NULL; &#125; else if(lrucache-&gt;lru_list_tail == entry) &#123; lrucache-&gt;lru_list_tail = entry-&gt;lru_list_pre; entry-&gt;lru_list_pre-&gt;lru_list_next = NULL; &#125; else &#123; entry-&gt;lru_list_pre-&gt;lru_list_next = entry-&gt;lru_list_next; entry-&gt;lru_list_next-&gt;lru_list_pre = entry-&gt;lru_list_pre; &#125; lrucache-&gt;lru_hash_map[HashKey(lrucache, entry-&gt;hash_key)] = NULL; --lrucache-&gt;lru_list_num;&#125;static void RemoveAndFreeListTailEntry(LRUCache *lrucache) &#123; info_printf(&quot;\\n&quot;); CacheEntry *tail_entry = lrucache-&gt;lru_list_tail; RemoveEntryFromList(lrucache, tail_entry); FreeCacheEntry(tail_entry);&#125;static void InsertEntryToListHead(LRUCache *lrucache, CacheEntry *entry) &#123; info_printf(&quot;\\n&quot;); ++lrucache-&gt;lru_list_num; if (lrucache-&gt;lru_list_num &gt; lrucache-&gt;cache_capacity) &#123; RemoveAndFreeListTailEntry(lrucache); &#125; if(lrucache-&gt;lru_list_head == NULL &amp;&amp; lrucache-&gt;lru_list_tail == NULL) &#123; entry-&gt;lru_list_next = NULL; entry-&gt;lru_list_pre = NULL; lrucache-&gt;lru_list_head = lrucache-&gt;lru_list_tail = entry; &#125; else &#123; entry-&gt;lru_list_next = lrucache-&gt;lru_list_head; entry-&gt;lru_list_pre = NULL; lrucache-&gt;lru_list_head-&gt;lru_list_pre = entry; lrucache-&gt;lru_list_head = entry; &#125; lrucache-&gt;lru_hash_map[HashKey(lrucache, entry-&gt;hash_key)] = entry;&#125;static void UpdateLruListEntryPosition(LRUCache *lrucache, CacheEntry *entry) &#123; info_printf(&quot;\\n&quot;); RemoveEntryFromList(lrucache, entry); InsertEntryToListHead(lrucache, entry);&#125;DATA_TYPE *NewDataType(LRUCache *lrucache, unsigned int byte) &#123; info_printf(&quot;\\n&quot;); if(lrucache == NULL) &#123; return NULL; &#125; DATA_TYPE *data = (DATA_TYPE *)MALLOC(byte); int try_again_time = TRY_AGAIN_TIME; while(data == NULL) &#123; RemoveAndFreeListTailEntry(lrucache); data = (DATA_TYPE *)MALLOC(byte); --try_again_time; if(try_again_time &lt;= 0) &#123; err_printf(&quot;malloc return NULL,already try call again %d time\\n&quot;,TRY_AGAIN_TIME); return NULL; &#125; &#125;; return data;&#125;int LruCacheCreate(unsigned short int capacity, unsigned short int hashkeymax, LRUCache **lrucache) &#123; info_printf(&quot;\\n&quot;); if(lrucache == NULL) &#123; return -2; &#125; if(capacity &gt; hashkeymax) &#123; capacity = hashkeymax; warn_printf(&quot;LRUCache capacity &gt; hashkeymax,then capacity set to %d\\n&quot;,hashkeymax); &#125; *lrucache = (LRUCache *)MALLOC(sizeof(LRUCache)); if(*lrucache == NULL) &#123; err_printf(&quot;malloc return null\\n&quot;); return -1; &#125; LRUCache *cache = *lrucache; cache-&gt;cache_capacity = capacity; cache-&gt;hash_key_max = hashkeymax; cache-&gt;lru_list_num = 0; cache-&gt;lru_hash_map = (CacheEntry **)MALLOC(sizeof(CacheEntry *) * hashkeymax); if(cache-&gt;lru_hash_map == NULL) &#123; err_printf(&quot;malloc return null\\n&quot;); return -1; &#125; memset((void *)cache-&gt;lru_hash_map, 0, sizeof(CacheEntry *) * hashkeymax); cache-&gt;lru_list_head = NULL; cache-&gt;lru_list_tail = NULL; err_printf(&quot;lru cache init success\\n&quot;); return 0;&#125;int LRUCacheDestory(LRUCache *lrucache) &#123; info_printf(&quot;\\n&quot;); if(lrucache == NULL) &#123; return -1; &#125; FreeLruList(lrucache); FREE(lrucache-&gt;lru_hash_map); FREE(lrucache); return 0;&#125; int LRUCacheSet(LRUCache *lrucache, unsigned short int key, DATA_TYPE *data) &#123; info_printf(&quot;\\n&quot;); if(data == NULL || lrucache == NULL) &#123; return -1; &#125; CacheEntry *entry = GetCacheEntryFromHashMap(lrucache, key); if(entry == NULL) &#123; entry = (CacheEntry *)MALLOC(sizeof(CacheEntry)); int try_again_time = TRY_AGAIN_TIME; while(entry == NULL) &#123; RemoveAndFreeListTailEntry(lrucache); entry = (CacheEntry *)MALLOC(sizeof(CacheEntry)); --try_again_time; if(try_again_time &lt;= 0) &#123; err_printf(&quot;malloc return NULL,already try call again %d time\\n&quot;,TRY_AGAIN_TIME); return -1; &#125; &#125; entry-&gt;data = data; entry-&gt;hash_key = HashKey(lrucache,key); InsertEntryToListHead(lrucache, entry); &#125; else &#123; if(entry-&gt;data != data) &#123; FREE(entry-&gt;data); entry-&gt;data = data; &#125; UpdateLruListEntryPosition(lrucache, entry); &#125; return 0;&#125;DATA_TYPE *LRUCacheGet(LRUCache *lruCache, unsigned short int key) &#123; info_printf(&quot;\\n&quot;); if(lruCache == NULL) &#123; return NULL; &#125; CacheEntry *entry = GetCacheEntryFromHashMap(lruCache, key); if (entry != NULL) &#123; UpdateLruListEntryPosition(lruCache, entry); return entry-&gt;data; &#125; else &#123; return NULL; &#125;&#125;unsigned char QueryHashKeyMapHasData(LRUCache *lruCache, unsigned short int key) &#123; info_printf(&quot;\\n&quot;); if(lruCache == NULL) &#123; return NULL; &#125; CacheEntry *entry = GetCacheEntryFromHashMap(lruCache, key); if (entry != NULL) &#123; return 1; &#125; return 0;&#125;void LruCacheInit(void) &#123; if(lrucache == NULL) &#123; LruCacheCreate(MAX_CAPACITY_NUM, MAX_HASH_KEY_NUM, &amp;lrucache); &#125;&#125;void ClearLruListCache(void) &#123; FreeLruList(lrucache);&#125;//void LRUCachePrint(LRUCache *lrucache) &#123;// info_printf(&quot;\\n&quot;);// info_printf(&quot;\\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\\n&quot;);// info_printf(&quot;cache (key data):\\n&quot;);// CacheEntry *entry = lrucache-&gt;lru_list_head;// while (entry) &#123;// printf(&quot;(%d, %d)\\n&quot;, entry-&gt;hash_key, *entry-&gt;data);// entry = entry-&gt;lru_list_next;// &#125;// for (int i = 0; i &lt; lrucache-&gt;hash_key_max; i++) &#123;// if(i % 10 == 0) &#123;// printf(&quot;\\n&quot;);// &#125;// printf(&quot;%x &quot;, (int)lrucache-&gt;lru_hash_map[i]);// &#125;// info_printf(&quot;\\n&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\\n&quot;);//&#125;//#include &lt;crtdbg.h&gt;//#ifdef _DEBUG //#define new new(_NORMAL_BLOCK, __FILE__, __LINE__) //#endif //void EnableMemLeakCheck()//&#123;// int tmpFlag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);// tmpFlag |= _CRTDBG_LEAK_CHECK_DF;// _CrtSetDbgFlag(tmpFlag);//&#125;//int main() &#123;// EnableMemLeakCheck();// LRUCache *lrucache = NULL;// LruCacheCreate(10, 10, &amp;lrucache);// int *temp = NewDataType(lrucache, 0x10000000);// *temp = 108;// LRUCacheSet(lrucache, 20 + *temp, temp);// //temp = NewDataType(lrucache, sizeof(int));// *temp = 108;// LRUCacheSet(lrucache, 20 + *temp, temp);// for (int i = 0; i &lt; 80; i++) &#123;// temp = NewDataType(lrucache, sizeof(int));// *temp = i%8;// LRUCacheSet(lrucache, *temp, temp);// &#125;// printf(&quot;%d\\n&quot;,*LRUCacheGet(lrucache,1));// LRUCachePrint(lrucache);// temp = NewDataType(lrucache, 0xffffffff);// printf(&quot;%d\\n&quot;, *LRUCacheGet(lrucache, 5));// LRUCachePrint(lrucache);// temp = NewDataType(lrucache, 0xffffffff);// LRUCachePrint(lrucache);// LRUCacheDestory(lrucache);// while(1);//&#125; LRUCacheImp.h12345678910111213141516171819202122232425262728#ifndef _LRU_CACHE_IMP_H_#define _LRU_CACHE_IMP_H_#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &quot;Debug.h&quot;typedef int DATA_TYPE;typedef struct CacheEntry &#123; unsigned short int hash_key; DATA_TYPE *data; struct CacheEntry *lru_list_pre; struct CacheEntry *lru_list_next;&#125; CacheEntry;typedef struct LRUCache &#123; struct CacheEntry **lru_hash_map; //hashmap struct CacheEntry *lru_list_head; //point to lru list head entry struct CacheEntry *lru_list_tail; //point to lru list tail entry unsigned short int lru_list_num; //current lru list entry num unsigned short int cache_capacity; //max entry num unsigned short int hash_key_max; //key range is 0~hash_key_max&#125; LRUCache;#endif //_LRU_CACHE_IMP_H_ LRUCache.h123456789101112131415161718192021#ifndef _LRU_CACHE_H_#define _LRU_CACHE_H_// Created by xiaozhiqiangtypedef struct LRUCache LRUCache;typedef struct CacheEntry CacheEntry;typedef int DATA_TYPE;extern LRUCache *lrucache;void LruCacheInit(void);int LruCacheCreate(unsigned short int capacity, unsigned short int hashkeymax, LRUCache **lrucache);int LRUCacheDestory(LRUCache *lrucache);DATA_TYPE *LRUCacheGet(LRUCache *lrucache, unsigned short int key);int LRUCacheSet(LRUCache *lrucache, unsigned short int key, DATA_TYPE *data);//void LRUCachePrint(void *lruCache);DATA_TYPE *NewDataType(LRUCache *lrucache, unsigned int byte);unsigned char QueryHashKeyMapHasData(LRUCache *lruCache, unsigned short int key);void ClearLruListCache(void);#endif //_LRU_CACHE_H_ Debug.h1234567891011121314151617181920212223242526272829303132#ifndef _DEBUG_H_#define _DEBUG_H_#include &lt;stdio.h&gt;#undef SHOW_INFO#define SHOW_INFO#ifdef SHOW_INFO#define info_printf(...) printf(&quot;[INFO] %s (%d):&quot;, __func__, __LINE__);printf(__VA_ARGS__)#else#define info_printf(...)#endif#undef WARNING#define WARNING#ifdef WARNING#define warn_printf(...) printf(&quot;[WARNING] %s (%d):&quot;, __func__, __LINE__);printf(__VA_ARGS__)#else#define warn_printf(...)#endif#undef ERROR#define ERROR#ifdef ERROR#define err_printf(...) printf(&quot;[ERROR] %s (%d):&quot;, __func__, __LINE__);printf(__VA_ARGS__)#else#define err_printf(...)#endif#endif //_DEBUG_H_ 补充前几天在同事的影响下,决定开始写自己的技术博客,并参考了同事关于搭建Hexo博客的文章还有网上一篇关于Hexo的文章. 同事-博客手把手教你使用Hexo搭建博客","tags":[]},{"title":"520 why","date":"2018-05-06T13:54:05.000Z","path":"2018/05/06/520-why/","text":"I love you wanghanyingwrite by erhuoqiang2018.5.6","tags":[]}]